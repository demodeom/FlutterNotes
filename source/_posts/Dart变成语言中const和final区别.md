---
title: Dart变成语言中const和final区别
date: 2025-09-21 09:24:40
tags:
	- 基础语法
categories:
	- Flutter
cover: "https://s21.ax1x.com/2025/09/20/pV4wFqx.png"
---

这是一个关于 Dart 语言非常核心且常见的问题。`final` 和 `const` 都用于表示**不可变的变量**（变量只能被赋值一次），但它们在含义和使用上有关键区别。

<!-- more -->

# const 和 final 区别

这是一个关于 Dart 语言非常核心且常见的问题。`final` 和 `const` 都用于表示**不可变的变量**（变量只能被赋值一次），但它们在含义和使用上有关键区别。

简单来说，它们的核心区别在于：

*   **`const` 是编译时常量**。
*   **`final` 是运行时常量**。

下面我们通过一个表格和详细解释来深入理解。

### 核心区别对比表

| 特性         | `final`                                                      | `const`                                                      |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **赋值时机** | **运行时**初始化（可以在声明时赋值，也可以在构造函数中赋值）。 | **编译时**就必须已经确定值。                                 |
| **不可变性** | 变量本身引用不可变（不能指向新的对象）。                     | 变量本身引用不可变，并且其值必须是**编译时常量**。           |
| **对象内容** | `final` 对象的内容是**可以改变**的（如果对象本身是可变的）。 | `const` 对象是**深度不可变**的，整个对象树的所有内容在编译时就必须完全固定。 |
| **内存分配** | 每次使用都会创建一个新的实例。                               | 在内存中只有一个实例（** canonicalized**），多次使用相同的 `const` 值会共享同一个实例。 |
| **示例**     | `final time = DateTime.now();` <br> `final list = [1, 2, 3];` | `const pi = 3.14159;` <br> `const list = [1, 2, 3];`         |

---

### 详细解释与示例

#### 1. 赋值时机 (Assignment Timing)

这是最根本的区别。

* **`const`**：值必须在代码**编译成机器码之前**就完全确定。它通常用于字面量（如 `42`, `‘hello’`）、其他 `const` 变量或常量表达式进行的计算。

  ```dart
  // 正确：值在编译时即可确定
  const a = 1;
  const b = a + 1; // 常量表达式
  const c = ‘hello’;
  
  // 错误：DateTime.now() 的值在运行时才能确定，无法在编译时计算
  const time = DateTime.now(); // ❌ Compile-time error
  ```

* **`final`**：值在**运行时**第一次被使用时才确定。它可以在声明时赋值，也可以在类的构造函数体内赋值（这对于根据构造函数参数来初始化变量非常有用）。

  ```dart
  // 正确：值在运行时确定
  final time = DateTime.now(); // ✅ Works
  
  class Person {
    final String name;
    // name 在运行时根据传入的参数确定
    Person(this.name);
  }
  ```

#### 2. 对象内容 (Object Immutability)

* **`final`**：它只保证变量本身的引用地址不变，并不保证它指向的**对象内容**也不变。如果对象是可变（如 `List`, `Map`），其内部内容是可以修改的。

  ```dart
  final myList = [1, 2, 3];
  myList.add(4); // ✅ 允许操作，因为 List 本身是可变的
  print(myList); // [1, 2, 3, 4]
  
  myList = [5, 6, 7]; // ❌ 错误：不能给 final 变量重新赋值
  ```

* **`const`**：它创建的是一个**编译时常量**，这个值不仅是不可变的，其所有内容也都是深度不可变的。你不能修改 `const` 对象的任何部分。

  ```dart
  const myList = [1, 2, 3];
  myList.add(4); // ❌ 运行时错误：Cannot add to an unmodifiable list
  myList[0] = 5; // ❌ 同样错误
  ```

#### 3. 内存效率 (Memory Efficiency)

由于 `const` 值在编译时就是完全已知且不可变的，Dart 编译器会对它们进行优化，让所有相同的 `const` 值在内存中**只保留一份**。

```dart
const a = [1, 2];
const b = [1, 2];
print(identical(a, b)); // ✅ 输出 true，a 和 b 是同一个对象

final c = [1, 2];
final d = [1, 2];
print(identical(c, d)); // ❌ 输出 false，c 和 d 是两个不同的对象
```

这种特性使得 `const` 在创建大量重复的不可变值（如图标路径、通用尺寸、默认配置等）时非常高效。

### 在类构造函数中的使用

`const` 还可以用于修饰**构造函数**，这允许你创建编译时常量的对象实例。

```dart
class Point {
  final double x; // 成员变量必须是 final
  final double y;

  const Point(this.x, this.y); // 常量构造函数
}

void main() {
  // 使用 const 关键字调用构造函数，创建编译时常量
  const p1 = Point(0, 0);
  const p2 = Point(0, 0);

  print(identical(p1, p2)); // ✅ 输出 true，是同一个实例

  // 如果不使用 const，即使参数一样，也会创建新的对象
  var p3 = Point(1, 1);
  var p4 = Point(1, 1);
  print(identical(p3, p4)); // ❌ 输出 false，是两个不同的实例
}
```

### 总结与如何选择

| 场景                                                         | 选择                                                      | 理由                                         |
| :----------------------------------------------------------- | :-------------------------------------------------------- | :------------------------------------------- |
| 值在**编译时**就能确定（如数学常数、配置字面量）             | **`const`**                                               | 性能更好，内存效率更高。                     |
| 值在**运行时**才能确定（如用户输入、当前时间、构造函数参数） | **`final`**                                               | 唯一的选择。                                 |
| 需要一个**不可变的集合/列表**                                | **`const`**                                               | 确保集合本身也完全不可修改。                 |
| 需要一个**变量指向一个集合**，但不想让这个变量指向其他集合，却**允许修改集合内部的内容** | **`final`**                                               | `final` 只保护引用，不保护内容。             |
| 创建**不可变对象**且希望享受内存优化                         | 使用 **`const` 构造函数** 并用 **`const`** 关键字来实例化 | 确保对象是编译时常量，可以被 canonicalized。 |

**简单记忆口诀**：

> 用 `const` 能解决的，就用 `const`，因为更高效。
> 不能用 `const` 的（需要运行时确定值），就用 `final`。